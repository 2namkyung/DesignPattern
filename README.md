# DesignPattern

1. 싱글톤 패턴
- 프로그램에서 instatnce가 한 개만 생성되어야 하는 경우 사용하는 디자인 패턴
- static 변수, method를 활용하여 구현할 수 있다

2. 어댑터 패턴
- 인터페이스가 달라서 서로 연결하지 못할 때 서로 연결할 수 있도록 하는 디자인 패턴
- Elec110V , Elec220V의 인터페이스 , 전자제품은 110V , 220V를 사용해야한다.
-> 집에는 110V 콘센트 밖에 존재하지 않으면 어떡할까?
-> Sol) 'Adapter Pattern'

3. 프록시 패턴
- 프록시=대리인 , 기존의 코드를 수정하지 않고 새로운 기능을 추가할 수 있다
- Cache의 기능으로도 활용이 가능하다
- Payment Interface가 있고 결제방법으로는 현금, 카드 등 다양하게 있을 수 있다.
-> 만일, 결제하는 데 걸리는 시간을 측정하고 싶을 때는 구현 클래스에 모두 시간 측정 코드를 작성해야할까?
-> Sol) 'Proxy Pattern' 

4. 데코레이터 패턴
- 기존 뼈대(클래스)는 유지하되, 이후에 필요한 형태로 변경할 때 사용할 수 있는 디자인 패턴
- 자동차의 기본 모델이 있고, 시리즈별 모델의 가격을 알고싶을 때는 어떤 방법을 사용할까?
-> Sol) 'Decorator Pattern'
-> A3 / A4 / A5 모델은 CarDecorator를 상속받고 생성자를 통해 추가 가격을 전달한다
-> CarDecorator는 CarInterface의 기능을 구현한다

5. 옵저버 패턴
- 변화가 일어났을 경우, 미리 등록된 다른 클래스에 통보해주는 디자인 패턴

6. 파사드 패턴
- facade = 건물의 앞쪽 정면
- 여러 개의 객체와 실제 사용하는 서브 객체의 사이에 복잡한 의존관계가 있을 때, 중간에 facade라는 객체를 두고 여기서 제공하는 interface만을 활용하여 기능을 사용하는 방식
-> ex) Client --->  facade  --->  FTP / WRITER / READER
-> ex) 전자레인지를 사용할 때, 타이머 전원을 입력하고 실행 신호를 전달 받아 마이크로파를 발생 시키고 직접 작동 시켜야한다면 아주 복잡할 것이다
-> Sol) 'Facade patter'
-> 단순히 버튼을 누르면 동작시킬 수 있도록 편리한 인터페이스를 제공한다
  
7. 전략 패턴
- 전략을 쉽게 바꿀 수 있게 해주는 디자인 패턴
- 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변경할 수 있게 해주는 디자인 패턴
-> 전략 메소드를 가진 전략 객체 , 전략 객체를 사용하는 Context , 전략 객체를 생성해 Context에 주입하는 Client
-> ex) Normal Stratety / Base64 Strategy 각자 전략을 가진 객체는 EncodingStrategy Interface를 구현한다
      'Strategy pattern' : 전략을 주입받는 Encoder Class

8. 템플릿 메소드
- 추상 메소드나 구현된 메소드를 활용하여 코드의 흐름을 정의하는 메소드
- 추상 클래스로 선언된 상위 클래스에서 템플릿 메소드를 활용하여 전체적인 흐름을 정의
  하위 클래스에서 다르게 구현되어야 하는 부분은 추상 메소드로 선언하여 하위 클래스에서 구현

